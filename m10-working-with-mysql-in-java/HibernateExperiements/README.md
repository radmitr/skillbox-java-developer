#### 10.6. Домашняя работа 10.2

**Цель задания**

Научиться подключать библиотеку Hibernate к проекту.

**Что нужно сделать**

- Подключите в ваш проект библиотеку Hibernate.
- Создайте класс для таблицы *Courses**.
- Напишите код, который выводит имя и количество студентов любого курса.

**Критерии оценки**

«Зачёт» — выведена информация о курсе.  
«Незачёт» — задание не выполнено.

---------------------------------------------

#### 10.10. Домашняя работа 10.3

**Цель задания**

Научиться создавать классы `@Entity` со связями для работы с базой данных.

**Что нужно сделать**

Создайте классы `@Entity` для всех таблиц базы данных и связи между ними для всей базы данных *Skillbox*.

**Рекомендации**

Изучите каждую таблицу и найдите связи между ними. Например, в таблице *Subscriptions* есть поле с идентификатором студента (*student_id*). В классе, связанном с *Subscriptions*, можно сделать связь `@ManyToOne` со студентом, а у студента будет `@OneToMany`. То есть у одного студента может быть много подписок, а у каждой подписки может быть только один студент. Аналогично посмотрите, где и какие связи можно прописать между классами.

**Критерии оценки**

«Зачёт» — написаны все классы для таблиц базы данных с указанием связей между таблицами.  
«Незачёт» — задание не выполнено.

---------------------------------------------

#### 10.15. Домашняя работа 10.4

**Цель задания**

С помощью Hibernate создайте новую таблицу в базе данных и заполните её.

В базе *Skillbox* есть таблица *PurchaseList*. В ней указаны имена студентов и названия курсов, которые они купили.

**Что нужно сделать**

Напишите код новой таблицы *LinkedPurchaseList*, которая заполняется на основании данных таблицы *PurchaseList*.

**Таблица должна содержать следующие поля:**

- *student_id*
- *course_id*

В таблице нет отдельной колонки с привычным идентификатором записи. В роли идентификатора здесь выступает пара *student_id* и *course_id*. Это значит, что пара значений *student_id* и *course_id* уникальна для каждой записи.

Связка *student_id* и *course_id* называется «составной ключ» (Composite key).

Один из вариантов создания составного ключа — написать отдельный класс, в котором поля будут содержать значения полей, входящих в составной ключ.

На примере класса *Subscription*:

```java
public class Key implements Serializable {

    @Column(name = "student_id")
    private int studentId;

    @Column(name = "course_id")
    private int courseId;

    //setters, getters, equals(), hashcode()
}
```

Класс  составного  ключа  обязан:

- быть `public`;
- иметь публичный конструктор по умолчанию;
- реализовывать собственные `equals()`, `hashCode()`, публичные геттеры и сеттеры;
- имплементировать `Serializable`.

Используется класс-ключ в `@Entity` следующим образом:

```java
@Entity
@Table(name = "Subscriptions")
public class Subscription {

    @EmbeddedId
    private Key id;

    @Column(name = "student_id", insertable = false, updatable = false)
    private int studentId;

    @Column(name = "course_id", insertable = false, updatable = false)
    private int courseId;

...
```

Аннотация `@EmbeddedId` говорит, что данный параметр является составным ключом.

Если поля ключа использовать и в основном классе `@Entity`, то необходимо запретить использовать поля для вставки и обновления данных дополнительными параметрами в аннотации `@Column`.

Для получения объекта из базы данных по составному ключу необходимо в метод `get()` объекта `Session` передавать экземпляр составного ключа, например:

```java
Subscription subscription = session.get(Subscription.class, new PK(studentId, courseId));
```

аналогично и для создания новой записи.

Дополнительные примеры найдёте в [статье](https://easyjava.ru/data/hibernate/pervichnye-klyuchi-v-hibernate/).

**Рекомендации**

1. Измените параметр `hbm2ddl.auto` на `update` в hibernate.cfg, чтобы структура базы данных обновлялась в зависимости от написанного кода классов `@Entity`.
2. Список возможных вариантов `hbm2ddl.auto`:

- `validate` — проверить схему, не вносить изменения в базу данных;
- `update` — обновить схему;
- `create` — создаёт схему, уничтожая предыдущие данные;
- `create-drop` — отказаться от схемы, когда `SessionFactory` закрывается явно — обычно, когда приложение остановлено.

**Критерии оценки**

«Зачёт» — в базе данных создана таблица *LinkedPurchaseList* и заполнена на основе *PurchaseList*.  
«Незачёт» — задание не выполнено.
